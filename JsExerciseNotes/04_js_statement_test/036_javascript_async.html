<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 异步编程Asynchronous, async</title>
</head>

<body>
    <div>
        <div>
            <h1>JavaScript 异步编程Asynchronous</h1>
        </div>
        <div>
            <h3>什么是异步编程</h3>
            <p>异步就是从主线程发射一个子线程来完成任务。</p>
            <pre>
                因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。
                但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们
                无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服
                务器的信息，我们是无法将它合并到主线程中去的。
            </pre>
        </div>
        <div>
            <h3>回调函数</h3>
            <p>JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。</p>
            <p>回调函数实质就是一个函数，启动一个异步任务的时候就告诉他完成任务之后该做的事情</p>
            <pre>
                function print() {
                    document.getElementById("demo").innerHTML="Hello!";
                }
                setTimeout(print, 3000); 
                // setTimeout 就是一个消耗时间较长（3 秒）的过程，它的第一个参数是个回调函数，
                // 第二个参数是毫秒数，这个函数执行之后会产生一个子线程，子线程会等待 3 秒，然后执行回调函数 "print"，在命令行输出
            </pre>
            <p>有时我们不必单独去执行一个函数</p>
            <pre>
                setTimeout(function () {
                    document.getElementById("demo").innerHTML="Hello!";
                }, 3000);
            </pre>
        </div>
        <div>
            <h3>Promise</h3>
            <p>处理复杂的异步任务</p>
            <p>比如多次调用异步函数，输出三次字符串，第一次间隔两秒，第二次三秒，第三次四秒</p>
            <button onclick="demo()">试试看</button>

            <p>构造 Promise</p>
            <pre>
                new Premise(function (resolve, reject) {
                    //要做的事情
                }).then();
            </pre>
            <p>Promise 将上面嵌套的模式改为顺序执行</p>
            <button onclick="demo1()">试试看</button>
        </div>
        <div>
            <h3>Promise 的构造函数</h3>
            <p>Promise 对象的构造函数是一用于创建Promise对象的内置构造函数</p>
            <p>Promise 构造函数接受一个函数作为参数，该函数是同步的并且会立即执行，所以又称起始函数</p>
            <p>起始函数 又包含两个参数 resolve和reject，分别表示Promise 成功和失败的状态</p>
            <p>起始函数执行成功时，它应该调用resolve()函数并传递成功的结果。当起始函数执行失败的时候，它应该调用reject()传递失败的原因</p>
            <p>Promise 构造函数返回一个 Promise对象，具有如下的方法：</p>
            <ul>
                <li>then：用于处理Promise 成功状态的回调函数</li>
                <li>catch：用于处理 Promise 失败状态的回调函数</li>
                <li>finally：无论 Promise 成功或是失败都会执行的回调函数</li>
            </ul>
            <p>Promise 函数被构造时，起始函数会被同步执行</p>
            <button onclick="demo2()">试试看</button>
            <pre>
                resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，
                如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作，reject() 
                参数中一般会传递一个异常给之后的 catch 函数用于处理异常。
            </pre>
            <p>注意以下两点：</p>
            <ul>
                <li>resolve和reject 的作用域指限于起始函数， 不包括then 以及其他序列</li>
                <li>resolve和reject 并不能使起始函数停止运行，不要忘了return</li>
            </ul>
        </div>
        <div>
            <h3>Promise 函数</h3>
            <p>我们可以把之前的计时器写成一个 Promise 函数</p>
            <button onclick="testPromise()">试试看</button>
        </div>
        <div>
            <h3>async </h3>
            <p>异步函数 async function 中可以使用 await 指令，await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。</p>
            <button onclick="testAsync()">试试看</button>
            <p>如果 Promise 有一个正常的返回值，await 语句也会返回它</p>
            <button onclick="testAsync2()">试试看</button>
        </div>
    </div>
</body>
<script>
    function demo() {
        setTimeout(function () {
            console.log('1');
            setTimeout(function () {
                console.log('2');
                setTimeout(function () {
                    console.log('3');
                }, 4000);
            }, 3000);
        }, 2000);
    }
    // Promise 将上面计时器的嵌套的模式改为顺序执行
    function demo1() {
        new Promise(function (resolve, reject) {
            setTimeout(function () {
                console.log('1');
                resolve();
            }, 2000);
        }).then(function () {
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    console.log('2');
                    resolve();
                }, 3000);
            });
        }).then(function () {
            setTimeout(function () {
                console.log('3');
            }, 4000);
        });
    }

    function demo2() {
        /*
         * Promise 类有 .then() .catch() 和 .finally() 三个方法，这三个方法的参数都是一个函数，
         * .then() 可以将参数中的函数添加到当前 Promise 的正常执行序列，.catch() 则是设定 Promise 的异常处理序列，
         * .finally() 是在 Promise 执行的最后一定会执行的序列。 .then() 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列
         */
        const p1 = new Promise(function (resolve, reject) {
            setTimeout(function () {
                if (Math.random() > 0.5) {
                    resolve('Success');
                }
                else {
                    reject('Fail');
                }
            }, 1000);
        });
        p1.then(result => {
            console.log(result);
        }).catch(err => {
            console.log(err);
        }).finally(() => {
            console.log('再试试');
        });
    }
    // 异步
    function testPromise() {
        function test2(time, message) {
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    console.log(message);
                    resolve(message);
                }, time);
            });
        }
        // 不同的时间间隔输出不同的文本
        test2(3000, '1').then(function () {
            return test2(2000, '2');  // return 不会中断then，只有主动throw 使其执行到catch干预中断
        }).then(function () {
            test2(4000, '3');
        });
        // 我们可以使用更简洁的方法
        async function asyncFunc() {
            await test2(3000, '1');
            await test2(2000, '2');
            await test2(4000, '3');
        };
        asyncFunc();
        // 异步函数 async function 中可以使用 await 指令，await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。
    }

    async function testAsync() {
        try {
            await new Promise((resolve, reject) => {
                console.log('开始');
                throw new Error('异常');
            });
        } catch (e) {
            console.log(e);
        }
    }

    async function testAsync2() {
        try {
            let value = await new Promise((resolve, reject) => {
                resolve("Return value");
            });
            console.log(value);
        } catch (e) {
            console.log(e);
        }
    }
</script>

</html>